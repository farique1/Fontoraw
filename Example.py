#!/usr/bin/env python3
"""
Fontoraw
v1.0
Output formatted byte information from monochrome bit mapped images.

Copyright (C) 2020 - Fred Rique (farique)
https://github.com/farique1/Fontoraw
"""

from PIL import Image
from itertools import product
from binascii import unhexlify

png_file = 'Example.png'  # PNG file to examine
out_file = 'Example.txt'  # Output file, text or hex_dump
out_type = 0                # Output: 0=screen and file, 1=screen, 2=file
data_form = 1               # Data format: 0=decimal, 1=hexadecimal, 2=binary, 3=hex_dump
char_w = 8                  # The character width
char_h = 8                  # The character height
srt_char = 49               # The first character to get (first = 1)
end_char = 91               # The last character to get
txt_pref = '\t\t decb '     # Text at the start of each line
data_pref = '0x'            # Prefix for each byte
data_sep = ','              # Character to separate the bytes
data_pad = 1                # Pad with zeros: 1=yes, 2=no
data_batch = 16             # Amount of bytes on the same line
line_gap = 8                # Insert a blank line after this many lines
line_srt = 0                # Start line number
line_inc = 0                # Line number increment: 0=no line numbers
byte_pad = 1                # Pad bytes with less than 8 bits: 0=in front, 1=at the end
luma_tresh = 170            # Pixel luminance to turn white (1). All else will be black (0)
verbose = 2                 # Messages: 0=none, 1=errors, 2=all

pad_arg = ''
bin_pad = '0' * (8 - char_w)
if data_form == 0 and data_pad:
    pad_arg = '03'
if data_form == 1:
    pad_arg = '02x' if data_pad else 'x'

# Interpret image character map
img = Image.open(png_file)
image_x = img.width
image_y = img.height
chars_x = image_x / char_w
chars_y = image_y / char_h
chars_in_image = (image_x * image_y) // (char_w * char_h)

if verbose > 1:
    print('Char width', char_w)
    print('Char height', char_h)
    print('Image width', image_x)
    print('Image height', image_y)
    print('Chars in a row', format(chars_x, '.15g'))
    print('Chars in a col', format(chars_y, '.15g'))
    print('Chars in image', chars_in_image)
    print('Get chars from', srt_char, 'to', end_char)
    print('Chars processed', end_char - srt_char)
    print('Generated bytes', (end_char - srt_char + 1) * char_h)

error = ''

if not (chars_x).is_integer():
    error += 'Character width not divisible by image width\n'
if not (chars_y).is_integer():
    error += 'Character height not divisible by image height\n'
if char_w > 8:
    error += 'Character width must be 8 bits sor less'

if verbose > 1 and (out_type < 2 or error):
    print()

if error:
    if verbose > 0:
        print(error)
    raise SystemExit(0)

chars_x = int(chars_x)
chars_y = int(chars_y)


# Convert pixels to 1s or 0s
def black_white(x):
    pixel = 1 if x > luma_tresh else 0
    return pixel


# Process image
# Convert image to 1s and 0s
for y, x in product(range(0, image_y, char_h), range(0, image_x, char_w)):
    img = img.convert('L').point(black_white, mode='1')

# Get pixels list (row by row)
pixels = list(img.getdata())

# Convert to a string
pixel_str = ''
for pixel in pixels:
    pixel_str += str(pixel)

# Get characters in order (top left to bottom right) and create the text output
cont = 0
byte = 0
line = 0
entry = ''
output = []
for col in range(0, image_x * char_h * chars_y, image_x * char_w):
    for row in range(0, image_x, char_w):
        cont += 1
        if (cont >= srt_char and cont <= end_char) or end_char == 0:
            for char in range(0, image_x * char_h, image_x):
                binary = pixel_str[col + row + char:(col + row + char) + char_w]
                if byte_pad == 1:
                    binary += bin_pad

                if data_form == 0 or data_form == 1:
                    entry += f'{data_pref}{int(binary, 2):{pad_arg}}'
                elif data_form == 2:
                    if data_pad == 1 and byte_pad == 0:
                        binary = bin_pad + binary
                    entry += data_pref + binary + ' ' + str(int(binary, 2))
                elif data_form == 3:
                    entry += '{0:02x}'.format(int(binary, 2))
                    # print('{0:02x}'.format(int(binary, 2)))
                    continue

                if byte < data_batch - 1:
                    entry += data_sep
                else:
                    if line_inc > 0:
                        txt_numb = str(line_srt) + ' '
                        line_srt += line_inc
                    else:
                        txt_numb = ''
                    output.append(txt_numb + txt_pref + entry)
                    entry = ''
                    byte = -1
                    line += 1
                    if line_gap and not line % line_gap:
                        output.append('')
                byte += 1

if data_form < 3:
    if entry:
        if line_inc > 0:
            txt_numb = str(line_srt) + ' '
            line_srt += line_inc
        else:
            txt_numb = ''
        output.append(txt_numb + txt_pref + entry.rstrip(data_sep))
    if out_type == 0 or out_type == 1:
        for line in output:
            print(line)
    if out_type == 0 or out_type == 2:
        with open(out_file, 'w') as f:
            for line in output:
                f.write(line + '\r\n')
else:
    if out_type == 0 or out_type == 1:
        print(entry)
        print()
    if out_type == 0 or out_type == 2:
        with open(out_file, 'wb') as f:
            for (l, h) in zip(entry[0::2], entry[1::2]):
                f.write(unhexlify(l + h))
